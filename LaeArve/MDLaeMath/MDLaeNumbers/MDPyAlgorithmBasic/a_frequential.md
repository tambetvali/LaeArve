# Frequential Mapping

## Preface

Before describing frequential mapping, step 1 in our number conversion method, which will be the most basic algorithm, we consider it's use cases.

It can be used to create Ponegates (second example), Assign Taú (first example) or to create indexed lists or dictionaries, where frequencies would meet _imaginary numbers_, i.e. sets of "hypothetical conditions", which hold true in regards of each index position; then, `f[i]` would mean value of `f` if `i`, where `i` is it's variable and value.

Notice that we use a as variable a, i in range(3) to assign i a property that it's all three values are considered at each use case, or @i in range(3) by which @i symbolizes each of the values, being unknown - then we are interested in theorems about @i value states, where i itself at the same time can have clear value and our system resolves.

In the second chapter after the use cases, there is the number digit mapping to ensure numbers are compatible frequential systems to math - compressed numbers remain at having these properties, but the case _why_ they have them is far less trivial - we can use Laegna numbers in compressed form, where the combinations done with digits remind more of decimal system.

### Logecs Frequenctial Numbers

Imagine a `Ponegative`:
- It can have these values
  - `I` - `Negotion` / `inegotion`; `Legodriad`
  - `O` - `Negation` / `onegation`; `Legadriad`
  - `A` - `Position` / `aposition`; `Rosidriad`
  - `E` - `Posetion` / `eposetion`; `Resedriad`

Each value is a _frequency_.

It has a _frequency map_ with the following `positions`:
`'[I, O, A, E]'`

For each `position`, there is a _frequency_:
`{I:I, O:O, A:A, E:E}`

If numbers are properly mapped, then ideal _frequential system_ has _each value at equal index to the value_ - this is a __balanced `ponegative`__; if values at `I` and `E` (local and global, you can use unsigned half-octave mapping for _mechanizing_ this number, where `I` and `E` are also opposites at `R`); values of the initial subsystem and the final supersystem are both such, then it's simply a `Position` along with `Roposition` / `Rosedriad`.

You can write this in several ways:

___Positional Mapping_ of _RT equality___:

Each `position` has equal value digit (positionally):

`IOAE`

___Frequential Mapping_ of _RT equality___:

_Each _line_ has equal value content (frequentially)_:

`E: E`

`A: A`

`O: O`

`I: I`

_Shortcut using style to denote _lines__:

`E: E` `A: A` `O: O`
 `I: I`

(given that code pieces have background)

(you can write long numbers on these lines, but usually not at `positions`. one standard writing for Laegna numbers is at one line, two lines half the width of line to denote `O` and `A` `positioning`; all four could be there at a line if above and below such double-line are also two halflines; and 6 can be achieved by what looks like three doublelines in order `VEAOIU` or `UIOAEV`, depending on your intent and meaning - first is order of magnitude, second is order of time, which is constant for all numbers and strings)

___Multiline Mapping_ of _RT equality___: @___Frequential Mapping_ of _RT equality___.

___Matrix Mapping_ of _RT equality___: @___Frequential Mapping_ of _RT equality___. You can say that multiline systems are matrices - where, anyway, unless you use `()` and `[]`, each cell contains only one digit. With spaces, multidigits and matrices, one can achieve _multidimensional `positioning`_, which still looks _logical_ (it converges to local reasoning).

__RT even and odd gitis mapping of RT equality__:
> Notice that I use "even" and "odd" backwards, because `R` and `T` are mapped backwards.

Each RT pair has properly fitting values:

`EE AA OO II`

Or, more shortly:

`EEAAOOII`

Consider that for each case, what matters is _frequential multidimension_ - lines create frequencies at the same digits, whereas `R` and `T` pairs create frequencies, and number digits are normally frequencies, i.e. while at octave 1 they form straight lines, they would form curves changing angles in direction of time - acceleration and decceleration occur, since the local area contains small amounts of information.

TODO4ALL: Learn frequential systems and how they form multidimensions.

Each of those examples can be compacted into one-digit ponegative, simply by stretching each dimension together; thus, matrix is a number, and while you can find different formats to write matrices, dimensionality of _Laegna Number Systems_ is not limited - the whole matrix can be fit into equivalent number by strict rules of mathematics; where those numbers _really exist_ and are not constructs or hypothesis; following Logecs, you map Laegna Numbers to systems with equivalent behaviour, where such behaviour might not mean the _local appearance_ of the same number, thus we apply Theorem of Imperfection to statement that this might not be the condition; where we cannot reach Theorems with simple steps, sometimes we _ignore_ those theorems and utilize the local behaviour of a number, with practical set of Theorems, which hold T=>R, from T to R. Notice that we avoid statement about ideal world, because the value would be È or E instead of Ä or A, which is targeted (A changing to E), or À or A, which is really there.

### Logex Frequential System

Let's map a System to 4 states:
`I`, `O`, `A` and `E`.

We get this _Frequential System_:
[`I`, `O`, `A`, `E`].

This is a _Symmetric Frequential System_ or _Frequential Symmetry_, depending on our views on it's metaphysics.

We could program a switch on it, given that any list could be used as frequential system based on it's properties:

```python
f = [`I`, `O`, `A`, `E`]
@x = ponegative variable
or: @x in f.R # X in range(f)

select(f)[@i = @x] {
    `I`: return `I`
    `O`: return `O`
    `A`: return `O`
    `E`: return `E`
}

@a => @x
@b => not @x
@c => nos @x
```

I use "`=>`" notation here to denote that `b` is optimizing to `x`.

We got 4 frequential systems: `f`, `a`, `b`, `c`. `F` is frequential system by definition, while `a`, `b`, `c` become tensors, which implies internal freqential system.

The code is running circularly, and based on this trying to see values in advance, given that __accelerated values__ (which could change over the circles) are not enabled.

`A` optimizes: into a value, which would imply `@a` into some `Position` (`Position` or `Negation`), given `@x` at `Position`.

`B` optimizes: into a value, which would imply `@b` into some `Negotion`, given `@x` at `Position`.

`C` optimizes: value of `@c` is not forced to `Position` `by` @x being at `Position`.

Alternatively you would have not and nos before @b and @c values, not before result: instead of changing towards implying this value, they would change towards having this value, but after a circle of calculations i.e. after passing the Taradox (successful situation of Paradox, such as their value would change based on itself, which indeed is allowed condition in Laegna, by _Theorem of Imperfection_ and it's _Logical Consequence_@_Laegna Theorem_).

Notice that the syntax is open, but you can grasp the idea of frequential system and tensor in sense of Laegna Logecs Systems; the _given_ variables and _equivalent relations_ to _given_ are _necessary_ and _enough_.

NOTE: _given_ in italic: once I was asked, what I mean by "given". Indeed that they were given.

We can have also this example, where "freq" is used like "def":

```python
# freq f.x(a, not b, nos c): Ponegative => f:
freq f.x(@a, not @b, nos @c) => f:
  case `I`: return `I`
  case `O`: return `O`
  case `A`: return `A`
  case `I`: return `I`
```

Here I don't give a variable, or I might give it before f.x as in "i | f.x"; also I omit that first f is f.T and second f is f.R - the first one is value mapping, the second one is positional mapping; in some language, this can be automatic for input and output.

We resolve this frequential map:
- `I` the hidden variable is set, somehow, by a, b and c. So we can iterate over a, b and c and check:
- For each case, calculations of i, which in simpler case would resolve into result.
- We can see that `O` is deductive, especially `I`, as _those frequencies map_ rather whether the value is *not* so and in case of `I` we respond `negatively` if it is, whereas `A`is inductive, especially `E`, because for `A` checks rather whether the value *is* so, `E` is the _implication_ of `A` further, and indeed maps specially well when `A` _accelerates_ into `E`. This is one of several numerically equal ways to map frequentials, given that value of `I` is the lowest value of it's range, whereas value of `E` is it's highest; value of `A` is lowest, but at half octave, so not so extreme but half extreme, which equals to not extreme; and `O` is the highest of it's range, but also not breaking completely. Numerically, checking different conditions we get the __frequential map solving__ - if it's flat, the numbers would need to always fit by `Logic`; now they change by `Logecs`.
- Freq, unlike function, tries each of it's values where *`position`* of frequency is the value; and assigns the result to this *`position`*.
- We can have `R` and `T` frequencers, by having just two cases both, where there will be `i` and `j`. Each combination of `i` and `j` with all the `logic` involved gives one _frequential map_, and it _resolves_ where _finity properly maps to infinity_, or a _given_ condition (which is given by user, _given_ as variable) is met.
- `@a` - "`@`" means `a` is _symbolic variable_, which means it can be resolved symbolically; just `a` would be rather an AI algorithm detecting value than logical system doing it itself. "`not @b`" and "`nos @c`" resolve into alternative case of before _given_ case: `@b` must not be at `Position`, or even Negation, and @c must not be in `Position`, or even `Negation`, _in effect_ to condition of _`i`_.

So, `freq` as compared to `def`: `def` would know one return value, but `freq` would either try all possible tensor values, in here we have 8 cases, and assign the results to frequential zones. `Position`, then, is of __higher frequency__ than `Negotion`.

## Introduction

To understand Frequential Mapping of Numbers, we need to understand frequencies in Logecs and Mathematecs, as given by previous two chapters. We are not going to use those frequential mappings in context of Logecs or Logex right here and now, where we might be much deeper if we do - for example, "freq" looks ugly if we specify f.T and f.R to it's input and output, and f and f would be enough: but it also disables cases, which are sometimes good; the latter cases as well can be written out by transformations.

### Mapping of Compressed and Standard numbers; Index numbers and Ponegative numbers

First, we need symmetric number space, in regards to zero, finite and the infinity. As we are interested in numbers on the straight line, and zero or infinity mappings except on the straight line create multidimensionals, points within relations of dimensional effects - their relations do not map to a line, but into a complex web of relations of points; given that in 3D, there is no "preferred dimension or axis", such as zero degrees or 90 degrees axe - the axe is necessity of projection into distinct 3 dimensions from space of rather "dimensinality 3", so if we operate with three numbers, we say three dimensions, and operating with metaphysical concept behind it, it could be space of dimensinality 3, or space with 3 dimensions if we also remove the _directedness_ from the three numbers, getting Three Metadimensions - it's basically and effectively a transformation from Octave 0 to Octave 1.

Infinities, in a certain sense, do not have length - for any point, a point would follow. For example, if we take line of 1 cm length, considering the infinite number of points inside, and multiply by itself, we get what in Laegna is also called 1², one in second power, where raise in R would make it more discrete, exact one, to _mechanize_ the conception - _mechanized_ conception lacks some depth or meaning, but correlates to tautological or strict sentence with the same value, I call it Parleon in Laegna - a value, which is tautologically strict and completely produces another value, which is rather symbolic or intuitively proven and does not correlate to any specific theorem, but only a mental knowledge. In Laegna and Latin, the value of 1 cm * 1 cm would be 1 cm². Now, if you take all the points and arrange into a line on equal projective power of point frequencies (approaching zero and subzero, where the latter add information density creating an R² space - we can see that 1 cm * 1 cm itself also exists in R² space). For straight line, value would be lost - you can now try first theorem of infinity, such as _Theorem of Line Angles and Infinities_@_Theorem of Line Angles_ by accelerating that space, where coordinates map obviously to square root coordinates, which could be kind of matrix in accelerated spaces; you can verify the content by using _Theorem of Discrete Space Mapping of Infinities_@_Theorem of Discrete Space Mapping_: by the theorem, for example you use fixed number x for side length of square, where `discrete x` = _continuous_ `cm`. __Theorem of Discrete Space Mapping__: By multiplying finite number of fixed discrete numbers, one cannot get infinity; in regards to all relations inter infinities, all proportions are always satisfied; for example if 1 cm = 10, then 1² cm / 1 cm² must be 100, but if you take 10² cm, it's 10 cm² = 10000, we 10 gives a whole number as well. Frequency-mapping of such whole numbers, you could also raise their preciseness, for example through octaves, and get quite a realistic result without losing a discrete mapping ability; indeed if you try to use the proportions with continuous numbers, as if 1² relates like 10², you would lose the correlations of discrete spaces - discrete space is at octave 0 if the point of octave 1 maps to point of octave 0; when I state theorem 0=1, I mean that, or I mean harmonic frequencies, or that O and A are connected to one curved point; it's a complex theorem where sin and cos hold, where in ZY space with additional dimensions Z and Y, one would not see sin or cos, but plain Position without yielding in the same flow; one assigns meaning of what was once Satan to them, ruining their lives, and consequently they now become their own Satan, ones who see the reasons and causes, but also the resulting harmonic, in the way where they finally resolved the problems; and one sees youth on such ways as reasonably smart while they complain about the way and it seems that life is full of Satan, where there are just causes and consequences. Who is able to resolve them, could become "guilty" and "punished", for in their hands could be the raise while it's not, a raise of Ignorant Mind. Indeed even the first theorem would allow to get a linear axe between Z and X, where R and T axes melt together and leave secondary dimension, which maps the aspect of multidimensinality and now contains values, which must be treated symmetrically to main axe when doing operations - this behaves like binary at octave 2 in regards to this octave system; by binary I mean logex because opposition such as pair of opposites gives 4 in Laegna - "yes and no" would mean each of the 4 ponegates; counting to two necessarily implies counting to four in this sense, as 2-polarity simply does not exist alone, without being actually projected in the four values.

To map a position (positive, I sometimes use this word as high-posetion or aposetion / äposeton or ä-poseton )