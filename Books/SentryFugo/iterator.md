# Iterator: our Agile process.

We have this kind of __iterative structure__:
- __Documentation__: Our Documentation of Code and Implementation should contain advanced features, which we don't plan to add yet. We are also an inspirational source, not only the provider: without solid advancements in AI technologies, I would never finish my dreams and plans; rather, the Documentation content could make a future AI implement it in straightforward ways.
- __Manuals__: We write manuals and users guides, which allow users to work without the centrifugal force: there is constant gravity to achieve results, but it works like a wind.
  - Notice that with my current manualization process: you could do most things manually, for example develop the AI embeddings, link back, and let us use the embeddings.
- __Automation__: We do automation in several ways, either we generate enough examples and training materials that one can adapt an AI, or we code it.

We are absolutely practical: we don't need complex implementations, when we can do it without. Rather, by slow experience, we are going to implement step-by-step, often rather sharing the code, snippets and functions with user. For example it might be more useful to add a feature to LM Studio, than directly to our site.

We are going to work with our tools, methods and possibilities and plans, and implement rather an _Application_ in sense of having requests and updates to open source programs we use, training for artificial intelligence, manuals for users; it's not just a set of _Programs_, such as a web page, which might not have so much application: there is a _standardization paradox_ that you lose creative content; for example I have no use for LinkedIn, because my kind of autonomous learner, with rather society-oriented activism and personal studies and projects to learn; while I have now reached a nice science - it's not very much confirmed so I have done basically nothing; the past job experiences being quite useless: such way, for example when I sent this "CV" to Google or other educated organizations, I was rather just blocked for being nobody. It's not convincing the 10 years "break" - but in free-form text, it's actually quite interesting time with a lot of contemplation to create new age of science ..well it's typical - Steve Jobs, by Intel, was treated more or less the same way, with another box of microcomputer.

## __Deptifying__:

We are going to add depth to our programs.

I have many ideas of perfect syntax of programming languages - but mostly, for special cases:
- Each nice syntax of programming language _uses resources_, such as the number of symbols on your keyboard.
- If you implement one nice syntax, you cannot implement another.

Rather than implementing everything, we need to work with _more depth of understanding_.

For example:
- Implement special case parser, which is able to parse and determine _this special syntax_.
- Implement tests and manual or automated verification, whether _this special syntax was followed in given case_, so that a more general grammar could still be verified, whether it implements the syntax, semantic alternative (where nice symbols are replaced with function names, for example), or different means to achieve the same.

We need to achieve metamodels:
- Assign metavariables, which can optimize the language in different directions; for example using question mark to verify a variable or to get it's output.
- One can create C++ templates to involve metavariables.
- One can create code to generate syntax analyzers for different cases.
- One can manually implement each case.

Our basic environment is GitHub and it's Issue Tracker:
- Implement a virtual, small version of it.
- Instead of real code, have a little language of _general code_, such as "Create a nice window."
- Generate issues, decisions and changes in this code.
- AI, in each case, would follow the history, have the microcontext, and get informed about language design solutions and general-case implementations.
  - Have abstracts: in certain tracker, some code is obfuscated (it means: it does not exist), whereas some aspects are changed properly.

For example, have 5 kinds of syntax, express them all in simple language (kind of "pseudocode") and follow several different tracks of issues and solutions, where the language is finally implemented with different features.

Grow up from there:
- It would first be trained on these basic simulations.
- Then, bigger context size would be used.
- Finally, it would connect this training with actual issue system, being able to follow this.

Others could implement this to other issue trackers and version controllers, but in my case I concentrate on making use of small number of chosen solutions: as we reach working systems, more users get interested.