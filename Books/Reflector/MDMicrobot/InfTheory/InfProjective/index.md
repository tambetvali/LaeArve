# _Projective Theorems of Infinity_:

TODO: while the theorem length is more or less fine; make a backup of this file and rewrite it in shorter, more clear paragraphs. Paragraph length is like double the ideal and it needs context, so we need a versions _more_ directed to simple model or fast analysis of an AI.

# __First Projective Theorem of Infinity__

_1Ainf_, _First Projective Theorem of Infinity_, __Radian Infinity Theorem__: _given an information density of a number_, radius _`r`_ = _infinity of positive numbers_, where the line of a circle is straight (radius = infinity) and _`r`_ = positive zero, where the line of a circle is the opposite of straight; after that the line is non-geometric in given space (with angle _through itself_).

_1Ainf_, _First Projective Theorem of Infinity_ (defining double-infinity): diameter `d` of the circle given in _1Ainf_ is the infinity of unsigned numbers; on our primary, zeroless system it's two infinities, which we sometimes map to single infinity.

_Counting nambers based on first Projective Theorem of Infinity_, __Radian Number Theorem__: we divide all the angles into numbers `i`, `o`, `a`, `e` (`ie`), or `1` to `4` (`14`) which on their own contain only the angle. Each number has given angle, with `e` being Infinity, `a` being plus Zero, `o` being minus zero and `i` being minus infinity.

_1Binf_, _Following First Projective Theorem of Infinity_, __Radian Infinity Theorem__: if we map Infinity, as given in _1Ainf_, to One, and One to given Infinity (in octave 0, `E`, and octave 1, infinite number of `E`'s); we get the outer space of infinity, where the previous `E` maps to Zero (either `I` or `A` signed/unsigned).

_Counting members based on first Projective Theorem of Infinity_, __Radian Number Theorem__: we divide all the angles into numbers `I`, `O`, `A`, `E` (`IE`), or `5` to `8` (`48`) which on their own contain only the angle. Each number has given angle, with `E` being Infinity, `A` being plus Zero, `O` being minus zero and `I` being minus infinity.

_Counting numbers, __Radian Number Theorem__: index numbers are counted based on their index values, and we call _compressed_ counting numbers _index numbers_: for example, Decimal system on it's own is often used to count in indexes, where _uniqueness_ and _order_ matter more than _number properties_.

_Finding natural and continuous numbers, __Radian Number Theorem__: Given the number scale of `AE` pointing from zero to infinity (remember how numbers are read - initial direction towards final direction or acceleration result in infinity to that same number); we multiply the number length with infinity `R` to form discrete number system, or `RÂ²` to form continuous number system.

_Uncountability of Infinities_: since infinities add dimensions, they are uncountable in lower systems; rather, we use _proportions_ and _symmetries_, for example the real angles.

# __Second Projective Theorem of Infinity__:

Task for reader: study the code in "code.md" or find it's mathematical counterpart (an algorithm, not necessarily an equation - the latter being more complex).

If you have a number like 0.(333), which is supposed to be infinite number of 333's after 0, then like 0.(3), it would give you the result 1/3, which gives 0,333333333 in your calculator. To represent this number, you call laesolveseries("333"), and you get the result of 1 / 3, which is the right answer.

You have one special digit "A", which means "10".

Prove the following: if you multiply the digit value with 10/11, you get correct results to compare each number. You can try, after this conversion, the proportions when operating with smaller digits, like using 0-7 for security. This is a solid, continuous digit space. You can have digit value not whole number, but floating point between 0 and 1 - then, we are interested in what happens with numbers bigger than 1.

Because you have all the mappings, and you can refer to calculations of infinity theorem of mapping infinity, because here we map: in the infinity calculations, where direct numbers give "unknown", "inf" or "zero", which equal just to different statistical distributions in frequential number space, basically nothing; if we relate to _calculations around_ we see that _logically_, continuous space does not have such strict break, where we can find the mathematical error: undefined value, when we trace it back, whould give us undefined values in the relations we see, but since we are not doing any statistics (using "random"), those calculations really _do not_ produce random numbers.

So in Laegna system it's the Truth-Tellers paradox: it's true that "some solution" is an answer, and it would cover our solution, but in this case we would use sum and multiplication to produce efficient random numbers without any complex math; rather, we _cannot_ get a precise and real mathematical random number generator, just dividing integers with zero. So here we have the contradiction, even if it's hard to conceive given that not knowing definitely relates to the way we solve mathematics by trial and error and probing in the theorem space with Isabelle, Coq or similar tool - but there, _Theorem of Incompleteness_ is applied to the surrounding space, and the right answer cannot be that the theorems we don't know actually _themselves_ are random: rather, whatever we do, they hold, and behaving randomly in regards to them is rather the "best solution" than correct one in strict mathematical sense.

So, what we do:
- Digits exist in Octave Z of a number in octave X. We divide digit value by given number to remap the space, and since digits themselves create exponential space by mere repetition of same value, we have done an exponential transormation of space.
- In the result, which is a number and not digit, we multiply the result with the same number to get the most trivial solution with some loss of information (the frequencies are actually in _distinct_ spaces or _parallel realities_ to paraphrase a man once sawn as _conflicting_ the base theory itself; using multi-line Laegna numbers or RT numbers, we can easily map many interesting infinities in such manner, and indeed we could extend them by adding more digits - but with a normal RT number we can say, there are not many _distortions_ so it's just rounding perhaps, given we are not inventing insane space - or in other words, while RT numbers cannot contain all information, they project the harmonics and thus the light and sound we would see and hear in such spaces, quite well, something would shine through..).

_Second Projective Theorem of Infinity_, __Spatial Correspondence Theorem of Infinities__: each change in our local number space, in it's power, has easy to understand equivalent change in higher octave; such that by multiplying each digit range by 2, in this case we have multiplied infinity value range by 2 - which means we have a _heavy acceleration factor_.