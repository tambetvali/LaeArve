# ‚ùì Prolog Natural Language Commands

A subset of Prolog should be implemented for specific pages, where you need given statements only: you can understand, how they have to modify and read your database or knowledge base; it can be "imaginary" block where you have inventive elements, but last-level conversion to Prolog should give something, or an AI should create alternative Prolog interface for the client of database, to be used for this version or standard series or standard subset of versions, for volatile, recursive or theoretical (ideal) program or set of programs.

Database is projected:
- From .md cards with End of File statements
  - For user .md recovery information about other cards, also with End of File statement to make it readable for Markdown database as a permanent item. Deleting or changing it would need subsequent entries, where active entries are at root, and subsequent entries including the active entry, earlier and unstable versions (O and E, where stable versions are having A tag in this version scope; each position means some property or partial id, whereas some positions are _linear_ and form a _common digit_ or linear value inside number with {...}, others are _digital_ and form one-letter numeric values where R=T, so two-letter projection would equal the same letter two times; this is the encoding for dimensional range, preciseness where including the past and future of data, we increase it's preciseness and also AI studies, what to do in the past and what to do in the past with concrete estimation of now, if this could be reliably programmed). "Could be" would be required for processing it's character, for example: "If I would be a stupid Calculator interface", "If I would be automated data entry machine for a Calculator interface", "If I would be Natural Language Emulator with this limitations" or the student machine of such machine.
    - If the AI is able to reason in such problem scope, it would rather consider those blocks similarly to hidden layers, by _not having this character_, but having _relative primitive combinations in data_.
    - Non-character mode cards should be in between, where the error is rather this: the answer has error if it syntactically, in statistically relevant amount but not under this, reminds of such machine, or if it cannot emulate the converted machines by it's cards, which have the answer in other way. The AI: would find a dimension for such patterns in case it minimizes the dimensional data also in pre-processor dimension, by giving an index value and position in it's tokens. I think token space should have preliminary size given by developers of an AI, but also additional layer with proportional symmetries and relations to contain them in same length of repetition or encode close to this, which should be easier if tokens could be written in different ways, but longer and more specific ways get better score, or one of those alternatives. Random variation should be reproduced when list is _completely_ ordered by one axe: R, and not if this is the partial solution for the general axe: L.

Database Items should be able:
- Templates have spacy commands in pseudopython
  - While this would work in Python correctly, producing equivalent results, you parse the python with simple data object parser and convert it to meaningful card, which can be done by user and used to alter the Python code.
  - The code would be convertible to two Python modes:
    - As part of a Class, if you give it a Class in law paragraph specifier.
    - As part of pre-Jinja processing, if it's "template" by "stage", or part of post-Jinja processing, if it's "jinja-processed Markdown page with code blocks", marked "process", where the code inside might run subsequent evaluations of Jinja template parts if it can not touch the variables, which won't get a value. I cannot implement this, but it should be able to process templates in meaningful order, in how it gets the information, and also allow stage code, which contains numbers for the stage: where certain digits start digit blocks, and for each value either more digits would follow or next block would start if eoe (end of expression) follows.
    - As part of post-hatml processing, where "stage" is "design" and it can modify the HTML design template if it still has open slots or modifyable slots (clients can rerun the past changes along with this new entry, in regards to it's dependencies and interdependencies).
- In template and database item:
  - Spacy-conversible natural expression code is given, or with user converter
  - Prolog is the important conversion, even if it's a weakly-mapped or intuitive 
  Prolog-like interface, which would still make some sense for more formal converters.

Database is made of: an index.md file would get chapters, or there would appear folders which become chapters, with same name with those .md files. Once they are added, database converts them to one document with chapters, so they have 5 title levels left unless subdocuments are mapped and thus the lower levels replaced with content indexes to other documents, which you can read in order or in one full document file, and the tree can get more and more branches if others backlink their chapters and thus reflect their own page with their own structure, into yours, if you accept it, or allowing others to emulate this with Spiders, if they accept it instead: for example, to contain rather specialized or private databases they add to yours, or when they are connected with databases of more advanced bots or only the local content is given, such as introduction to school or publisher, which is providing server power to your content (also kind of backlinking, but they might create a link, which then includes your page or book as part of their chapter where chapter title can have such link to your title and it's settings part in later versions; multiple such links without separator lines or empty vertical whitespace, would produce _melted_ (as I call garbage-collected output, which has a nice scope for the user and their "variable" request) or _merged_ pages).
