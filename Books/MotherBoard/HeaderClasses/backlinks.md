# What this code will do

## Architecture

It will do:
- Read folders along with files with same names with extensions; folder extensions are ignored and only the last extension is used: TODO: implement exceptions like ".tar.gz", but have it initially two times if you want to have it for folder, also.
- It prepares to merge them in raw reader, by collecting them together and associating with two Anytree instances: one which allows to search the original file position, other in the projected system. By this you can do conversions, because you can associate them - to get _Directory_ and _Folder_ items, as I separate the raw and projected structure, similarly to how they are commonly used: Folders are meant to be applications, while Directories contain easily raw files you don't want to see. The names are used interchangeably.

Then, it does backlinking:
- By having another source referred on paragraph like "@@ [name](link)", you assign your page to normal content to this page; either after: to _terminal_, which adds to the end; or mixed: mix with other mixed items into the beginning. The folders will be garbage-collected: number of chapters, size of initial chapter and following (nested) chapters are considered.
- Each content can do forward-linking by "@ [name](link)". Then, content from other page or other pages in comma-separated list of links will be added, as part of this chapter, or chapters (list of one items will generate one chapter, as associated with the following includes). This is used like "include" or "import" statement in programming, and you just copy other book dynamically to your page: initially inside our system as we don't support outside-links (it's just one collection right now, where you can create copies to include in yours, for example in "History/Laegna" documentation and personal server; initially you find just some random Flask applications at folders with "app.py", some for testing the functionality).
- Backlink targets can be created: "@ __Target:__ [site](link)" would add it as a backlink target, primarily providing with url. You can also use HTML tags inside Markdown, which create link targets for "#", altough you have to implement the functionality, or you can give names to headers: on next line from "# ..." header, write __Name__: practicalfilename where the file is in projective space you show in Flask client, but I think the Spider would easily use the Applications directly, and the Server could be more stateless: you could have each served instance as a version, branch or subbranch in your emulated Git, where the clients private links would remain, but you could easily integrate something like Apache to not run each link, where the client would ask for Markdown files: you have to add this hook to Motherboard code, then. You would generate the Markdown dynamically, and keep only the outer layer open-sourced for your client or public, so this way _this_ module does not implement code protection, for example: if public space, your server might execute only "Executables", where this is admin right, but you have to implement the protection in the basic language: I would rather keep those packages somehow usable alone and together, where they code is copied into larger architecture(s), and they would locally sometimes serve in the common format which is flexibly designed to include Python code, Markdown and Jinja2 Templates, which should design Python code and Markdown or HTML, where the replacement does not know that yet: it happens inside Markdown. It's different from Flask itself, where you run templates and code together; where the static objects of Python code, such as classes, might be marked static (default), which means they are initialized once, perhaps later versions would add each instance with changed name and you put the template commands inside comments. The code itself is executed after Jinja: this provides hooks _before_ the template is parsed, for example to set it's variables: this is _OOP_ or _Functional_, which means you need to use a class or function; whereas the latter is _linear_, where Python code not belonging to "class" or "def" will be executed afterwards (initially I make so simple parser: keywords "class" or "def" to introduce a block make it so that this is executed before, and new classes would be added later, where you have to construct the word with template function; but the linear code outside class and def: all of it, in one part, is executed instantly after Jinja2 finishes).

So:
- (__STATE 1__) Before templates, you can use the code to set some parameters of Jinja2 templates, which merge into your Flask templates invisibly. This, anyway, uses classes and def's, so you create an instance of class and execute the property in your "cycle".
- You can also run your own code in this phase.
- It has availability flag and checks the one of others. The same for each state 1, 2, 3 etc.

- After templates have been applied, the rest of your Python code will be executed. Both before (__STATE 2__) and after (__STATE 3__), you can respond to this state.
  - Noticing you, additional classes can still query your interface despite your code or "introduction" finished executing; you can produce output before it's rendered, in later versions just to stdout.
  - In later versions, consistent version of Python server would run, including the file mapping and initiation, where each code is to be ran once with "__setup__" tag or something, where it exists in setup script "if .." blocks and sets "__webmain__" false, which would introduce our output, but not other inclusions, which won't provide it: or they just switch your stdout off or read it themselves.
  - We could actually parse for accepted subset of Python if we want client interfaces: it's based on local variables, limited imports and stateless functions; pehaps if you can translate it to JavaScript. One could also use emulator or directly, implement support for some version of "Javascript": some are for local service, where you can download some compilers or interpreters for ECMAScript languages.

- 
