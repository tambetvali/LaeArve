# Laegna Number System
_Subtitle_: Laegna Number System for Programmers, Artificial Intelligences, Computer Systems and Standard Calculators (of Laegna General Math and to be used in simplification of more advanced implementations).

_Programmolinguistic Introduction_, __Aggregate Meanings of Code and Math__: This is a description of Unified Laegna Number System for Programmers, especially for "Assembler" - the mode of programming, where you might implement underlying primitives, before your language gets libraries and your AI starts to figure out the more high-level meanings of your language use, such as specific parts needing colored fonts and specific parts not; this is a version, where any kind of irregularities are removed. I use the word "Assembler" for an initial condition of our code, where we must not get high, especially unforeseeable complexities, and implement basic number types, truth value tables etc. Later, intuitively, one can do much more complex connotiations to number types and implement theor logic, such as number type for frequencies, which give even numbers only if they fit your musical taste. Normally, for advanced number types, let's have what I call an "Aggregator" - a simple object, which is not necessarily standard (such as using each letter in the same meaning), but which is a basic Laegna number, such as "AAEEA", and which will have aggregators on it's own, converging to one-digit Laegna Logecal or Mathematecal value, such as "A" or "E" depending on your positional priorities for given number "AAEEA", where one level of complexity might be in between with "AE". AI, compiler, optimizer or logical solver might learn about your Aggregator and it might be able to figure out about your class, for example whether it's a Posetive; anyway, you are not going to straightforward removing the work from programmers, such as assuming we could define an universal meaning for "Yes" and whether we are ironic or not, or simply fail our cause so that it starts to sound like "No"; still we expect a simple client able to barely read a few digits; list, indeed, could turn 500 aggregators into one unified aggregator, and this is why I call it so: in case of your class being abstract interface to hundreds of other classes, it would turn their Truth Values into unified wholes.

## 