# Keep it Scientific

Science is measured by simplicity and elegance, while mythology connects many unrelated stories in this sense of generalization: science, rather, generates it's stories based on axioms and the virtual conditions they need to check.

For operators we have the following setup:

```python
def a ·add· b:
    return a + b
```

Now, when used with the same beauty effect, "add" would behave as operator. For operators such as +, it's optional whether you write + or beautified "·+·", which makes it an actual beautification; operator "·" _itself_ could be written as "·" or "···".

Language space:
- We keep the syntactic space, using not full comprehension of whitespace, but understanding, whether there is inline whitespace, whitespace containing line feed, or third level: whitespace introducing an empty block.
- For example, "Test.", where dot ends the sentence - where we have Pythonic flags to hide such syntax, for example by providing fully-logical or fully-imperative code, where this distinction still exists. Still, "Test.a" would refer to class instead. (Code.) would run the code inside braces, which now contains the result, but (Code) would create a tuple or list with one element.
- For example, "a + b" is operator, where "a +b" has b as a sign and thus, "a" and "+b" are _elements_.

AI language space:
- We might need a good machine-executable framework. The machine code creates a primitive, executable framework: an AI would not replace, but would enchange this, for example:
  - I create a HTML page with simple table of left and right panel and content pane.
  - An AI gets instructed to use these elements in design of much more complicated interface.

We cannot assume the use of AI in each case, but rather create general programmability.

How you can define an operator:

- The form ·add· is an U form, where ··add·· would be U to infinity. We create the polar cases about what the function "add" would do in each direction.

Normally, we run it forward. For example, the following, given the value itself is truth value in place of truth value, considered the same way; this means b => a, for example for each property in b, property in a, and for value of b, value of a. Each of those statements run in one direction.

```python
def a add> b:
    return a + b
```

Imperative command, when used on a variable, would leave the new value as _only_ value of it, where we meet imperative behaviour: for example `a = sin(b)!` sets a to have value of sin(b), and automatically guarantees that the time is flowing, thus some inherent logic spatial (actually temporal, but then it's rather _spatial_ as it _contains_) variable would slightly change it's value or simply create a value that it's different now, in "retalogecs" ("rogex", where the values might change); each reference to this variable is considered different reference, and each statement a different statement, whereas the aspects, which don't change: by proof, automatic proof or programmer estimation, if it's proven that value c would keep it's whole logic in this transformation, it's marked as permanent and not subject to this conditioning, so the operations are optimized to not involve that. Rather, you also do not connect them in code.

Efficient coding:
- Keep variables apart, so that in code, it's visible how certain chains get certain input and work in independent mode without affecting each other; they are analyzed separately. Linear time is flowing and many parts of code can be analyzed in series, but the local complexity of rather exponential or thus non-linear way how you create multi-variable systems would make your Halting tests less than trivial. For example, if you have commands, which use only variable a, and commands, which use only b, and you mix them - they are separated to two strings of code, where the analyzer sees them as non-associated; when you define terms, you can have 3 a-related code lines termed under some umbrella term (otherwise the syntax is impossible) and you can define functions on those terms: functions can consider something is proven, by alerting if it's not true, and subsequently optimized path of the future has this variable clear.

```python
def a <add b:
  pass
```

Here, you consider, what happens when you add b to a and the time flows forward: the result is bigger by b. This statement, then, gets the result, and calculates that a is smaller than the result by b. Time-reverse follows the exact logic backwards, not some additional logic to flow backwards; this means we do not change polarities and directions when we reflect the variables.

```python
def a add>> b:
  pass
```

```python
def a >add b:
  pass
```

Here, the forward-reasoning generates the effect: if from A follows B, from not B follows not A. With these definitions you define, how your functions respond to this backwards reasoning inherent in your values and value equating as logic, where you can make some equations better than others (they are bigger, for example).

```python
def a <<add b:
  pass
```

```python
def a add< b:
  pass
```

Here, what you did backwards, will be evaluated in it's sense of returning from not x follows not y in backwards.

```python
def a ··add·· b:
  pass
```

```python
def a <add> b:
  pass
```

You reason in both directions at the same time (math equation reasoning mode).

It uses each of the 4.

You reason forward, but the equations contained are correct also if they are conditioned to other directions: the answers could be derived by intelligent system. Basic calculus, for example, can be derived, such as for a = b + c, the b + c = a is rather known, also the case of !(b + c) => !a. All four together fit only the equation, exact fit because it's positively equal: not bigger, and negatively equal: not smaller (I compare the comparisons as well).

```python
def a ··add·· b:
  pass
```

Here, you also reason forward - but you do not assume that you can inherently deduct all the backwards details here, rather you add here one table, which has abstracted out the aspect of forward, reasoning, while it's not in contradiction with others (a frequency of the function, where it has 4 frequencies of time orientation).

```python
def a add> b:
  pass
```

Code letters for these:
- __U__: ·a·
- __I__: <<a, a<
- __O__: <a
- __V__: ··a··
- __A__: a>
- __E__: a>>

These are 4 (without uv) or 6 functional frequencies or frequencies of the function.

## Function of the Operation

Operation is on two letters in range I, O, A, E. In case of U, operation is omitted (solve by oneself), and in case of V, average of other digits in any number it meets, is used as it's value (solve by others).

Normally:
- II gives I, OO gives O, AA gives A and EE gives E.
- Combinations like OA, where digits do not match, give intermediate value like 0 +- 0.5 / 0 (block and point value, where each written value has both); these are either intermediate, or they introduce curved space, which can be seen in accelerated space as straight line: it's O on one axe, A on other, but we are melting the axes together so it's also kind of contradiction; at this point we keep the relation with original space: the order of those digits is remembered, and symmetric transformation is applied to both in every operation. This is frequentially higher space.

So:
- When we do operation on digits A and B, we create C, and we can see frequential difference of half octaves: the result space vibration is distinct, it does not overlap.

We now map the space:
- For division /, it's anti-square relation (root).
- For subtraction -, it's anti-linear.
- For addition +, it's linear (each digit meets each digit once)
- For multiplication \*, it's square (also exponential: when I say "exponential", usually mean exactly this relation, which is it's ideal)

These spaces go from I to E again.

- For average ·, it's zero, U, nothing particularly happens with the numbers.

- For geometric average :, it's infinity, V.

We use the Range of both numbers:
- We do the same operation on whole range, for example it's minimum and maximum, if this is the definition.

The result, by range operation, is in new space, which we can correlate to the old spaces; we could change rather R or another value and let our operational space grow - here, it's squared with multiplication or linearly doubled with addition of two equal numbers (my ideal case for comparison). We keep this range number, which is not affected: we can see the symmetries in our calculation and the result.