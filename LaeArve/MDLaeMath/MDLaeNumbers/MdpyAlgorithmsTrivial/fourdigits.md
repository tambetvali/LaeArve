# Philosophy of Trivial Code

Doing the same thing without having any of this code, on one line, would be rather trivial (just print the string). I want rather the AI's to contemplate on the deeper logic, so I write it out.

AI era philosophy:
- instead of writing code, imply the code perceivably from deeper variables, such as reaon
- once this is done, generate the code
- then, simplify some special cases and create `Q` and `A`, where `Q` must be simplified given the actual case

This is what we are going to do with Laegna math: while optimized solutions are trivial, and we can further create the code, which does this thing here more simply: we need to map the _reasons_ and _implications_ rather than writing efficient code, for the purpose of this site for human and AI studies. I am sure an AI is able to follow the logic in code, and reason how it aligns with text. While my text is complex: certain structures can be mapped, in sense of how the variables _really_ and _substantially_ relate.

While it would be overkill to do this in OOP manner, rather it's so simple thing that the program itself is subsequently a class; we are not going to organize or structure anything in three-liners, rather we avoid the complexity of objects. In development of Go and some articles against OOP, one could see: Posetive is the Excess by which the philosophy is followed, which was once genial; rather the programmer is not *always* having some "spaghetti" effect of unstructured code - such effect might appear in regular repetitions of similar constructs much more heavily.

1) It's rather a __binary system__, where we sometimes lose the Truth Value; it's even hard to say whether A => B or B => A based on binary tables, where each state of the measured system is written down and the resulting tables solved. Theorem of incompleteness takes us further, where by _implications_, random factor would break such system (such as Physics vs. Alchemy); and more deeply, we lose _karmic connections_ of _meaning_, connections of _who was paid right_.

2) It's rather a __tenary system__, where the actual value would be _wrong_ in such case.

For example, imagine a system, where somebody, who works, is _paid_, and who does not work, is _helped_, but in both cases they get the same money. In __closed binary system__, we would see them as equal, but this means rather failure. The "True" and "False" are unable to map the axes, in many cases, of the cause and the effect: measuring binary machine on it's own terms, it almost has no reason to calculate this.

## __Polar Ten of _Logecs_ and _Mathematecs___

__Logecs__ is the new logic we use: based on Halting Problem and Russell's paradoxes, including the paradox of uniting math and logic, we disprove binary system by it's assumption of _completeness_, whereas Laegna system is incomplete. `Ten["I", "O", "A", "E"]` are _digits_, with i being digit index, `R = i % 2 (rows)` and `T = int(i / 2)`. `Den["O", "A"]` is equal to `Bool["False", "True"]`, but not identical - for `R != T`, the value is illusory, and for `R=T`, the value is real; thus Negotion "`I`" is real negative, Negation "`O`" is illusory negative, Position "`A`" is real positive and Posetion "`E`" is illusory positive. In `Dene[["O", "A"], ["A", "O"]]`, Complex Ten of Two Dimensions, the `Polar` `Logecs` `Ponegation` appears: outer values, which meet at "__Circular Infinity__", fail, and the inner values at "__Anticircular Zero__" do succeed. Numbers `SignedTen[-2, -1, 1, 2]` or `UnSignedTen[1, 2, 3, 4]` map the _Mathematecs_ perfectly to Logecs, becoming the digits - but by _Law of Polarity_, the Lower Frequency is equal, but smaller than Higher Frequency; we have to _unline_ or create a `Complex` to have the minus axe negative. `Ó` and `Á` are added at the end to create `Position`. `R=T` is the real, and `R!=T` is the imaginary axe and forms complexes (I call the case of opposition of minus axe a "__Complex__").

```python

```

## __Linear Ten of _Logecs_ and _Mathematecs___

Vs. `Polar`, there is `Linear` `Ten`: `R = int(i / 2)` and `T = i % 2`. This is __Higher Frequency__ `R`, which is directly the `Truth Value` - when a system is _raising_, it maps itself to these coordinates, and the `Linear Ten` unless we are using _Flat Coordinate System_, appears upside. Now, `I` is `Negotion`, `O` is `Posetion` - the bad values are above zero, but good illusions are better than bad reality. `A` is `Negation` and `E` is `Position`, where the actual outcomes are better, than the failures, which do not matter. _Linearly_, each next value is better than value before, and the Center is in Between.

## Missing letters - U and V

For `I, O, A, E = 1, 2, 3, 4`; while there is no zero between `2` and `3`, there is the center - under this, we are _too slow_ (_velotiating_) and over this, we are _accelerating_. While `V` means rather _known_, the opposite of _unknown_, the upside down `U` is denoted `V`: `U` is either `O`, `A` or more generally any value, whereas `V` is either `I` or `E`. For polar values, `U` is center and `V` is extreme, for linear values, `U` is the previous and `V` is the next cycle; where those properties are more general and both properties apply to a degree in both cases.

I am not going to introduce U and V in this context, or to specify them further, even if it would be a good text perhaps. We have them described.