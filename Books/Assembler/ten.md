# â˜¶ Ten

I introduce a frequential object called Ten.

It's:
- Having a digit, which has four possible values.
- Having a frequentier, which has inner representation of four digits for one-digit Ten:
  - I: represents it's definite not-being
  - O: represents not being of it's definite not-being
  - A: represents not bring of it's definite being
  - E: represents it's definite being

Frequencers can be split into subfrequencies, which are beings of not being of separate values, and superfrequencies, where they are themselves in one of these states towards something. The line of these values is considered smooth, where in direction to each value you get closer in equal steps, so the calculation space has to be mapped accordingly.

We can have such Ten with frequencer:

It has getter:
- When receiving value of such Ten, one will know it's real value.

It has setter:
- When setting the value, one will set the goal or ideal value.

It has counter-representatives of both, where you can set the getter value or get the setter value, the last being more important: you can check what your goal is. "#" before the variable or number could be used.

It's represented by pair of Den frequencers:
- A small frequencer, which maps the O and A values, and is called T axe as it's forward-preceding, history based value.
- An other, which maps the I and E values, and is called R axe as it's future-predicting, or establishing the actual value in future, and it goes reverse in time.

To establish such structure, we use the Polarity Law: the logical constructs are mapped in time same way, and the backwards axe is not turning the actual time into it's reflection. This way, same line can be used.

Imagine a block, written out in this example (consider a pythonic dialect where "blocks are not written out", to describe the dialect with your code file; where we will not have one standard, but we teach an AI to configure the grammar, where we are little more apt to keep the semantics, which can be expressed in different ways - it's an aim similar to the one of Visual Studio, aim of generalizing the base language, while having different dialects, even paradigms):

```
{
    A = 7
    A = 3
    A = 7
}
```

When this has been ran infinitely many times, the value of A _at circular point_, which is _the mean point for future value estimation_ would be 7 as in beggining of the code. We run the value check circularly, instead of passing back in time like Prolog: this way, we have imperative logical language.

We use optimizers to consider blocks.

We can write a term, where A remains (hiding blocks this time):

```
trm arem():
    A = 7
    A = 3
    A = 7
```

The term and definition alternative implementations run in synchronized time, where for each connection, the past and future values must fit - for example, many blocks can do addition at the same time, so that you have simultaneous implementations of a <+> b. If you implement plus in one, minus in other, the past and future would not fit, and this would give an error.

```
def arem():
    pass
```

This, when it encounters sequence defined in arem, would think some underlying condition is proven and run it.

Equality:

Consider this: A => B. From A follows B.

We write it this way: B = A. We read that from some value of A, same value into B follows, where it can be function call.

If the sentence perfectly fits it's given condition, it does not have to know which ones are variables and which ones are constants: if the answer approximates the input variables.

Otherwise:
%i - iterator i, which has #%i or it's constructor equal to the range, and value of i also gives this as a range and some current value for other functions. If you use such in position of indexes, all the range is mapped to the same operation and it's done in every combination:

map[%i, %j] = Add(%i, %j).

After this, each element of the map contains the sum of the row and column. It's done in one line without iteration.

While function behaves well as a dictionary: function calls have input defined and it can be a function over it's space; () brackets behave on T: values. [] brackets behave in Space: they can be index or function of range (executing functions over ranges of the variables), depending of the class. Each class of math keeps it's range, and it's rather good to calculate ranges to other programs, such as indexes. You can calculate remappings here, and create matrixes, which remap.

## Ten frequencer

It has two dimensions in time: forward-dimension and backwards-dimension.

Consider this:

Sin(A) = B.

You could want value of A to be changed based on B, or vice versa. If A and B are Tens, one happens with OA values, other with IE values.

Mathematically:

Considering the OA axe:
- Sin(A) = B.

Considering the IE axe:
- B = Sin(A).

One of those values circulate upwards, the other one downwards.

They both have two frequential values, their appreciation of being false and appreciation of being true.

Now, one Ten aggregator will be created (and you have getter and setter for this):
- While you can have 2-ten aggregator containing two 0..3 values, you can have one with common effect.
- You combine R and T values, where:
  - Coming back in time to correct in negotive direction is closer to I, correction to posetive direction is closer to E; notice that "value to be corrected" is their false value.
  - Forwards in time, A sets the excpected future value as well to E, and O sets it to I. This is the actual correct answer: once the local calculation has corrected it's axes, it will have it kind of here, in it's initial intent and not future, but in higher frequencies: by value, higher frequency is closer to the future of the calculation or it's sensory effect.
- You have these dimensions:
  - R dimension of Dens of this Ten is between IE and OA. You create a number from all these digits, and this is the R if it's corrected, T if the value has not been corrected in infinity, then it has also been applied. [Math: floor(Ten / 2 = Ten.R)]
  - Class metamorphosis: if it could do metamorphosis, where we could change class even in initializer and add optimizer requirements to account for complexities as needed (optimizer, which would rely on this simplicity or accept user); initially, Den would contain the content without R, and it would be only O or A - once the value is corrected, it would become more specific. Otherwise, the value is "_" or empty until the cycle between future and past has given degree of basis. Variables know they optimize slowly towards ideal, and in Ten variables, simple axes could represent this topologically: Logecs is higher space than logic, despite it's simplicity.
  - T dimension of this Ten is left or right inside one half; either it's "IA" or "OE", the other half of information: Dens turn the Ten into two halves, which contain two bits, but also enough range of values to together represent all 4 values of the Ten; they might and might not have such hidden bit that they do this in pairs, not assigning constants: in diagonals, they tend to point to one end of one diagonal, together, so representing a single letter. [Math: Ten % 2 = Ten.T]
  - When two inputs form the value into two pairs of Dens, then put on top of each, correct statistics appears of how much a digit must equal one or another; or you can simply take the averages where for you, the value of getting correct value in infinity and locality is important: it has the monopoly for "A" value, where True ("A") was in there in first place, and also accepted in infinity as True ("E").

So, as in imperative language, time flows. If variable, after a circle, has changed it's value, use acceleration numbers, which go beyond their frequencies and accelerate: or you can give a logical error if this is relative to static axe.

Den is two frequencies:
O: O or A
A: O or A

It represents: if it's initially set to O or A, would it change this value. Your code won't change it if it can be without, and even change to the same value could be considered: this frequency is equal to it's position, if the value would remain such, or it's the other value where it would change into.

Ten, with it's four values, in the middle aggregator: [and those four letters being it's frequencies, where we can also use two Tens to represent both of two-bit frequencers, which as you can see they are]; it takes the positive values as important thing that if it has them, it has.

Imagine a math algorithm, where two are mixed:

A + B = C

A travels upwards, C travels downwards:
- B = C - A is the condition to solve with low-frequency Dens, at O and A vibrations of the Ten.
- A = C - B is the condition to solve with high-frequency Dens, at I and E vibrations of the complete Ten.

Other tens can be assigned this Ten: there are no limitations to form complex webs of dependencies, but following a set of simplification rules would be more efficient.
