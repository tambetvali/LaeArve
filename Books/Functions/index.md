# Main functions are point, vector and matrix.

Our numbers kind of represent points, because they are represented in two-dimensional space with additional, frequential dimension - source of multiple parallel dimensions; which are parallel in sense that we use equally positioned numbers for each frequency, and dimension(s) because they are countable in that direction, and different by apparent laws, interacting with each other and having fundamental properties: in Fourier Diagram, where two-dimensional image is used to represent frequencies inherent in numbers, since they can give closest results to straight line in given dimension.

## Point representation

### It's space

We use the space component separately:

the space where the function is defined, is aligned _on the same line_, by polarity theorem: where the values would go further, the function number goes further, not backwards as we might project. The local point goes further to perfectly map the R and T.

### It's own function

Number a.

a().

This brings a to next octave or applies _frequential transformation_ in the local number zone: for small numbers, infinity symmetries are represented in local symmetries, including V: the virtual point where the number is mapped to exact infinity, which in local digits only involves an approximation digit up and down, which can slightly influence the first and last digits in some kind of roundings for some kind of computations. In neither direction, as long as we approach and don't directly take limit, our pixel space would symmetrically outround a digit in fourth dimension, where we add dimensions as we map number inside to be of same size with number outside: this becomes exponential, but for 4-digit-value and 4-positional Laegna number, it's using this perfect sequence to simplify each component without your intent, or rather _effort_.

a^0.5().

This brings it half octaves up: the downside, really, does not bring you _down_ in laegna, according to polarity rule: I use the old rule in place of my calculation, because I want to signify it's mapping, which might introduce historic knowledge when used properly, as historicians they are looking for _Truth_.

Point, Vector or Matrix b.

a(b).

Returns b multiplied by a, componentwise and directionwise, notice that matrix exponent multiplication factor towards it's own function is 1/4, you rather play with coordinate axes and you normalize with frequential numbers, aligning the same number of digits and digit values: vectors also play out as sequences.

When called backwards:

a(b) = X.

The inner component, less firm than the function (which would be separately marked as variable, and altered as alternative, for example to feed AI input to set it's function result).

## Vector

Vector can change frequency.
- In Laegna number space, you use the sum and multiplication values for different frequencies, where the symmetries represent each value: a simple two-dimensional coordinate system does not, for example perfect circles would be mapped to squares, which is why I say square turns to circle and circle to square in half-dimensional and full-dimensional mappings; and think of digits: where, if you in division turn the number backwards, in the next frequency where you map - and + together, you would turn none of the numbers backwards, so you have R and T difference: I and E square-mappings, where they are two times reversed.

Vector function on it's own has frequential setting, the one of where it points: add "A"'s to beginning of positive, "E"'s to negative numbers to have the vector length. The length would change when you change the frequency, you are doing symmetric mapping on different scale, and while the numbers do not represent infinity - it's solved where their R, coordinate system, does not represent too, but you need to count infinity of these numbers to see if they together, would map the infinity properly, thus doing considerable amount of work in their scale.

Represent laegna number with curve, or in 2-dimensional fourier diagram like the one on music machine; or more complex for some machines with line-based strategy rather than image-based. Laegna lines are fixed numbers of pixels from up to down, and digits from left to right, when the affine translation is correct. You use the averages. Thus, you can resize the matrix.

To have proper matrix, you use multiple digits to represent each digit, between {} such as A{IOA}E, where IOA is actually higher-base component, and it's inner value is used: take third root in scope, to say, or actually exponential level 3 down the size and scale, and it's digit-sized, but precise number. Using A{{I O A}}E, it's digit-wise infinite, going to accelerated space only on that digit. This way, if you circularly run static logical code and there is +, - etc. inside for the number to become larger every circle, it just approaches accelerated space and there is no contradiction, if the code does not output (infinite with side-effects), the resulting value would be like average of each value, with averages of their positional length being the length, use R and T of each and r<->; every block can be such loop, and the code itself can be: when effects happen backwards in time, it's interesting, like back-propagation.

When vector is called with an argument, it would apply it's vector transform to the argument, transforming 3 dimensions and rather the existing dimensions.

Multipliers like v^3(1, 2), where v is the vector used as a function, are used to represent _length_ or _R_ value, which does it 3 times in this simple case, but example two times in reverse if 0.5 is used, and to 1/4 counter-space in case of negative value, which transcends the infinity of rotation and goes straight over (use the digit value like a fractal, in new space just use the same digits). You can do half of this if you don't understand the math of the second part.

## Matrix functions

### Space

By altering Matrix Space, it can be made project otherwise; here one can affect the weights and biases.

Addition and multiplication are done in series, invariably: both contain R to the other, their space, which is repeating the _change in value of two subsequent variables of operation_, such as in I * E, the difference of I and E. The space of multiplication remembers the addition-relative change of it's subsequent components, and vice verse: the addition has an axe, where each subsequent relation of multiplication has two-compoent difference, what would be the multiplication analog to this addition and vice verse. For example in 2 + 2, they would contain very similar numbers.

By this rule of invariable adding and multiplication, a matrix which utilizes those operations would contain twodigit value for each digit: T digit would be addition, R digit in multiplication scale.

It also holds for division and subtraction: they use the same space for R values, because they are opposites of multiplication and addition, in this order. So, you get symmetric response, the _matrix function_, and you can optimize it rather in two-dimensional space, additionally the scope of a function (space of it or range, like the one in this section).

### Function

Matrix m.

m(t).

Where t is time, would map it to future or past by this matrix, in relation to it's orgins; where t is another matrix, it would apply a projection on it's projection (R) or projection again to it's mapped points (T); this function simplifies away each transpose, where matrix is invariably just function taking certain input and giving certain output, and not reversing any coordinate spaces by law of polarity.

## A.I. DL model representation

### Space

Space (class type Model: let's make classes variables to train AI about R: the possibility to alter the function).

R is definable:
- Simple source: Projection (R) or Position (T) Matrix, Vector or List (R or T), Point Coordinate (R) or Point (T). Point in one-dimensional space is number, a base dimension to count other dimensions: they form metadimension of 3 dimensions, where directions, scopes and sizes are not known, but 90 degree and cubic space measureability is known. n-dimensional space over 3, even 3.1 or 3.2, can be mapped to 3-dimensional space with distortion, and source of distortion is the frequential scope/range deficiency of symmetries: frequential symmetries, not definitely number symmetries, where you need more space. You can calculate ideal coordinates for this mapping: use for Laegna numbers. You can project distorted space, where you evaluate either right angles, right distances (under certain rules of sharp turns of space), or for example right spatial symmetries which rather comes with right distances, without limits. This is to project sphere on square with my method: it would distort angles on paper, but the same space is perfect for symmetrically aligned numbers, where positioning of zero is impossible otherwise: it needs for number 9, the 10-treshold of the dimension, and positional 9-digit dimension, and you need usually to multiply something like both into their exponential factors with each others; better if your basis is 2, not 9, because you meet the same exponential situation many times in row with grand infinities, and a few times for common mappings of infinities, such that the ones going on in geometric mapping, where certain symmetries overcome infinity mappings: x and y switch in a way that it leads to infinity symmetry of their coordinates, while they have exact center limit value in this turn, which is rather the infinity itself: around this, switch from x/y to y/x and vice versa, with this conversion being the same on both sides.

### Function

Model m

output_vector = m(input_vector).

Gets (serves the chatbot, runs the pre-trained model or brain with knowledge) the estimation.

m(input_vector) = output_vector.

Sets (trains, fine-tunes, or remembers user selection for forward-guessing somehow, which I call "Brain Without Knowledge") the estimation. Schedules fine-tuning and returning the fine-tuned model in standard (gguf) format.
