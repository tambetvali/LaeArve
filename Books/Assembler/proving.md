# тли Proving

As the Assembler nor Laegna Programming Language is a prover, the proving must be done by Programmer's capabilities, with prover or AI or software planning.

Programmer is then satisfied with the condition that some statements hold true:
- They add the statements to the code, possibly with "!?" in the end of sentence to verify they are True, or ?! to give an error should they happen.
- Exception handling should be mapped to normal variables: whenever something is able to map an exception, they can set the Ten _true_ using "I" and "E", and the same way errorous conditions should be handled in form input.

From the form, automated provers, which scan the code, can find out whether:
- Certain assumptions are definitely true.
- They could be true, given the assumption was true.
- They are definitely false.

"?!" and "!?" should be used to build "Controllers": functions, which are ran at the same time, using ",," as sentence delimiter to run multiple parts of the line at the same time,
or having several blocks like this:

```
  Statement
,,
  Statement
,,
  Statement
```

Each variable the block relates: either conditional statement, for example breaking under some values, or the return value related to input must match. As long as they keep the basic operators under Optimization Level 0, the logic which controls the execution tracks would be kept on low logical complexity: they cannot form more than linear and basic exponent levels of combinatoric complexity.
- Preprocessing complexity: how many days or weeks should the parts of compilation work; does it finish in different phases: for example, a compilation might start from compiling the program code, then train AI's to reflect it properly, then bundle them together; iterative compiler would run like this.

Programmer builds the assumption using "trm" and "def":

trm AssumptionLine(input):
  Lines of condition of trm, where _for_ and _while_ and _if_ and _elif_ blocks can each have an empty constructor, in which case it's verified some track exists.

def AssumptionLine(input):
  Maps the term into a definition, code lines to be executed.

Each of those is assumed to _be run at the same time_, so to execute something one after another, they must build a class where they have different instances.

If terms are defined to map into "?!" and "!?" definitions, it is enough to write a code with structure in definition of term, to execute the code of it's definition; the definition might contain the process where you see some theorems hold. You functions, which assume them, would see in advance: in case the program continues there, the theorem would hold; so they map the future estimations where you see assumptions coming into theorem space, but not into it's time: directly, the line leads to assumptions of future values.

For example, definition of sinus function might follow only certain traits of a sinus, but it can map this into it's properties over the sinus and consequently produce a proof.

Proofs have optimization levels and worker intensities: the process would run the code to it's highest quality, but each optimizer on their own is improving; you must handle the intermediate states.

How it's logically possible:
- "Time" is the parent of all objects, functions, operations etc.
- It contains _an improving variable_, change in time, where the current time is inherent condition of each operation.

The user will write random proofs in such form, associating with different classes, threads and subprograms, so that they would not be ran in excess. The conditions they are interested in, will be proven: but a prover has a certain track to see whether it's _true_, where it can, on higher optimization levels, run higher complexities and also make the values or their relations more precise.
