# â˜¯ Assembler

__TODO__ (this rather _is_ TODO, where this dict list might contain just lists like such): Folders, which contain same-named md file, will be linked to that file, which has _higher priotity for user_, and _lower priority_ for program, appearing "vice versa" to their vocabulary. I add "tag" on special line: if not processed, it appears as text to your DHTML, but Markdown should not remove this and Json has all the tags added.
__Tag__: checkbox("Done", not @todo).
- Programs process the folder, and have file as linked content.
- Users process the file, and have folders as linked content.
- This affects the _garbage collector_, which gives bigger space for programs, creates "embed" callout for users to create embedding linkbacks with their AI and resource properties before the first title, and using lower-level titles before the first title as "terminal" commands, executing them in strict language. Markdown has to resemble e-mails: what comes before the first title, or subject, is in general and not strict terms - Markdown format - rather the headers.
  - Headers support Study Card and Document formats, where dictionary items will be tags; when _colon_ appears __inside__ bold emphasis, it's not dictionary item, but emphasis on a word; if it appears _outside__ it's marked as dictionary item, and AI will be teached a term: "Give me definition of __term__: termtodefine.
  - __Wiki__ is used: an example output of AI is generated, and each time it's _fixed_ if inline dictionary items do not follow the format. Several wikis for different dynamic outputs would help to teach the fixes to the AI: "AI feedback for version 1.7: fix this card: Q{question} A{answer} C{ContextLoaderModel}". Context loader will change context dynamically, reloading 3 or 4 times per session. Larger model is started when content is marked important, will generate context, and context appears to document embeddings.

__AI Feedback__: each conversation is processed and embedded to document space, included in document collection in real time: it can pass it's own memory as given percentage of context, more using if other context providers provide less. AI would learn random fluctuation through theory and mark important points as memory of stateless system, where because of this, we follow the stateless design - we consider it's simpler, and allows to use _human-readable urls_, where the runtime of the system is thus open sourced; it's available in json view.
- Json: we use Mistune to decode the HTML. Simple syntax is not to do this in reverse, and this is why we have this library: if it's extended, we also provide optional extension. We could want to add to decoder: record start and end of each block processed, so that property for line and character numbers, including file position in bytes, is added to each Markdown block. This way we could integrate our own processor: currently, to include Markdown files, we simply process the head-level code and titles in this process, where the Markdown is not able to execute subsequent code.
- Subsequent Markdown files are linked to subsequent items in the tree.

Laegna Assembler is Language, which sees Logecs version of the math and logic: it sees each mathematical design in terms of primitives, which does not involve the _dimensionality_, but only the process for single digit or repeated combinations, where exponents are indeed linearized in RT space, and everything you can do with them is known as linear system design or logex, subsequently rather Machine level above Assembler. Assembler language is trivially the same with programming language, but you cannot turn off the optimizations: for example, actual execution of exponentional growth, if you don't design it into simple linear system, cannot be permitted by changing the language flags; thus it supports different implementation.

Mathematecs comes as next step: logical systems are evaluated, and mathematecs is added to their design.
- It creates Logecs output when it assigns __aggregator__, a necessary value for each object and instance: it recovers to one letter, for example for Object: whether each instance is considered sucessful.
  - It can create fractal calls to those instances, forming math when it calls back basic assembly, which is fractal topologically higher frequency, one octave up in mathematecal space.

For example, numbers for multiplication appear always in square space: where each digit is squared in this space, it's exemplified in frequential local system, which in turn is combinatorically trivial thing you can do with referential digits, the number positions and their dynamic attributes - with letter and accent, you can change them in trivially small amounts, so you better choose your variable types. With 14 and 58 selection, you can choose the dimension towards velocity and acceleration. Track the plus and minus down: they exist in linear space, and thus when digital system is repeated in infinity, infinity should be solved, thus you use _minimal change in it's model-sized projection, called digit, freqency or a number_. Each is expressible and clearly defined as must-be mathematical property. The single digit itself, needs to be projected as subset of the matrix, and for "words" (the space-separated numbers of rather a matrix, where you can use multiple dimensions for precision when dimensions have no-caps letters to form the variable type out of digits, additionally, to represent matrix). In matrix you change projection: you work with R rather than T. T is the Tensor, which is the local value. Matrix normally supports multiplication, but Laegna can be insensitive to two operations: higher frequency is then multiplication, lower frequency is addition.

Here you see answers also to my previous topics, why it needs to be between Q & A: here I can sense the future, where some people got problems: why this is _in advance_, where you can compare the clocks: _into the future_ or _into the past_. Addition, indeed, adds "I"'s to the number positively, like they are in 14 space, but negatively where they are in 82 of four, the 8 and -2, second from the end as it's also in Python: index -1. We still also have a zero, as we can see it's needed to index that: we have V, for example, in regards to U, and V goes backwards as well, it's matter of it's octave where we count full octaves (around the number) or local frequencies, disturbances of octave not even seen at higher view of rather continuous function of the result, where they are indeed topological fluctuations through _existence_ scales of _any_ member, topologically present in small amounts even if they render as _chaos_: too many members to class.

__Multiplication__: from A * B and A=B follows, A.R + B.R.
__Addition__ : from A + B and A=B follows, it's always plus 1.
__Growing system__: put U rather between 3 and 4 to understand this frequential system, which is frequential multiplication of it's R, or R of the parent rather (but we never mention this triviality as it's a ponegate - let it fail a few trials since _sine_, the deductive level of processing with this linear set of inputs, is trivial even for brain, and the processor). Plus and minus become the I-scale factors, moving between O and A, and extending this dimension: the math system extends, and extends the Truth Value with frequency; but consider you need _multipliers_ for the rest of the matrix: to infinity, you have same precision, so digits are Denary Pairs: you can frequentially extend them, achieving Y scale, where you rather have the value, but not the execution. It's the _visionary_ on global basis or _managemental_ scale on local basis. This plus 1, where it would stay, you consider each time `I` is `added` for the matrix: you see addition. And each circle, which gives repeated answers for logical clarification, where _and_ is multiplication and _or_ is positive division using I the same way, as division coordinate in 1/4 space: rather value and the unit coordinate space, which is rather 18 in regards to materix being it times itself in space. If you use digits with power, you can organize them into oscillations and frequencies, which you also need at information level: it's the behavior of numbers themselves, in Laegna made trivial.
