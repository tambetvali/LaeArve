# Environment

This contains only selection of quality resources: for things, which are large, hard to install or complicated to describe what they do, and whats the practical purpose, they would go to another book to teach all kinds of products.

__Notice:__ while every tool or library described here on these pages might not be used by us, it's _relevant_ for us, for example the clients would _gain_ by having this access; for example, I plan to describe several programming languages, while this site is using Python: for example, while using Python, one might be interested in Julia to do their math calculations real time, where Julia console can be used to interact with it - in Python, there is more emphasis on creating a whole structured code file, so Julia is slightly better; whereas, in Python, it's much more suitable to create a _product_, because it shines with structurality and makes a little tradeoffs in complete math. Prolog, also, can be used to solve logic problems - I don't know what I can program with this, but if you want a standard logic problem example here, prolog block might be better idea than Isabelle or Coq, because it's programmatically structured and practical, vs. the insane amount of technical information you need in full-fledged prover. I expect that people are better off if they have those tools: I can say I have not learnt any of three in excess, but I solve my concrete problems with them and search for the proper syntax each time; it's big doing to go through Isabelle documentation, much like learning whole math in it's completeness: anyway, you can learn a few classes, some basic axioms of a theory, and the proofs look quite natural, you can prove something based on it. Then, indeed, you can use it here in Python. So I put some relevancy that you can join our AI training crew, rather than that you have just set of programming tools installed to access my website.

Here, our environment is described - tools, bots, libraries etc.

Out system is an __open standard__ and we don't aim to implement it completely: ideas are welcome and users will install some basic frameworks, but they can do without: for example, Spiders can understand the links and backlinks very well (they appear as standard links).

Like Markup, our primary and favourite standard, we allow clients to implement any subset, and we work on supporting those efforts based on each case; so we keep those pieces of code rather small and readable, and describe each programming effort in documentation: both in advance and in support, also the lessons learnt. The documentation should be able to reproduce the code, and allow other users to create already modified versions.

Finally, for users, who like completely static pages: we allow to put the Markdown directly online as folder structure, preferrably in GitHub to support versioning, or to static page. From structural constitution and perhaps a few standard-compliant elements, the Spiders can still build up a whole AI training and user access system, for example where AI is trained based on documentation, or it's incorporated to some document collections, other users can do full work and link back and ask for passport pages, where the accept has to be given to backlink this page, for example; the Spider can collect the backlinks and still make them visible. Other web clients, such as flask pages, can connect to this structure and reserve it in more dynamic way. People, who just want to convert their documents to Markdown and build a folder structure, are welcome. Additionally, HTML-only pages could be handled by Spiders, if this is simple and well-structured HTML, which I call "open source" (because closing the source: basically _obfuscation_, so if you clarify and clean the content, it's the straightest road towards open source, even if you are just structurally inspiring your commercial clients, who are allowed to do something "your style"). What matters is the source itself - once it looks like open source, people typically manage how much they "steal" and how, because they can fetch some data, for example show your books in another format to their home users etc., where the more clarified code will _look like an open source for somebody_ - this is why, to not create OS, you really need an obfuscator, which could be compiler or special-case-feed of information, which hides the source of the specific details, for example providing calculations, but not the equation or algorith.
