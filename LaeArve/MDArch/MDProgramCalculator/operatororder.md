# Operator Order

Operator in one sentence is orderless and the following function is used to unite velocity and acceleration:

```python

enum Time:
  Past,
  Present,
  Future,
  Center

Class VelocityAccelerationCurvature:
  # This is the common curvature for velocity
  # and acceleration

  # Additions and subtractions to follow
  addictives = None

  # Multiplications and divisions to follow
  multitudes = None

  def timeForm(time):
    # Whether the number is centered at zero,
    # on left side or on right side of zero;
    # or everything is calculated in regards
    # to it - use · at left and right side
    # of the variables and numbers.
    self.time = time

  def addComponent(component, operator):
    # Last operator connects to first element
    # again, time determines which variable is
    # R and which is T.
    self.components.append[component]
    self.components.append[operator]

    if multiplication:
        multiply or divide with operator
        shift addictives in regards as T axe
        use velocity components so that their
        relative sizes to each other are
        considered and not influenced by
        these corrections

    if addition:
        add or remove with operator
        shift multitudes in regards as R axe
        use acceleration components
```

Got confused? Well I didn't want to waste words

(2 + 4 * 8 + 5 *)··

Each operator has time to the future, pointing there with two sides of the operation; notice that : would point in reverse. (operators under question)

2 is added 4, so the multitudes are multiplied by 2, following this change from their aspect.

4 * 8 means for addition, there is 2, and 2 is added to it to keep it invariant to change.

8 + 5, indeed, does something like 13/5 on multitude invariancer; don't forget with 2 it's rather 10 + 5, with 4 it's rather 12 + 5.

* at the end connects back 5 to 2 and creates an accelerative effect: 2.5 times acceleration factor exists, expressed by a frequency shift of something like 2.5 octaves, where unsigned variable is converted 2.5 times to signed: (unsigned => signed)^2.5.

I have not checked this completely for mistakes in particular calculations as it's quite fresh solution for me - I have been anxious about creating the invariant order of operatives, where for example we let the user define operatives freely and I particularly do not like to follow these priorities, it's always confusing especially when switching languages: it's typical to write ";" at the end of lines in python, and turning back to C or Javascript, start omitting it which has just become a habit - how long we learn to _switch_, where we still somehow imagine we are doing the same thing.

For example:

+ 2 * 5 + 8

Additives 2 and 8 remain in 1/4 relation while 5 would change the axe 2.5 times if time moves forward, or 8/5 times backwards, notice we can move in and out with · and :, also recovering from such operation with :.

2 +* 4

This is now a point accelerated operator.

We use the fact of 2-based system of coordinates; and also lack of syntactic elements where we seem to override - more complex math, still, has a substantial basis for more advanced invariants and less guessing, but initially we do all special cases and tag the change in semantics.

## What operators do at all?

We assume that each operator is it's number.

I and E are multitude:
* With R² space, they multiply and divide.
* In this space, each combination is used with each combination, a factor which turns R multiplication into normal matrix multiplication, which is not defined separately and additionally, it can be simplified into a number - we simplify matrix spaces, and for this the computer contemplates on dimensionality, much like my meditations, to repeat my mathematics and it's mental test or simulative trials.
* When we multiply, something relative happens with plus and minus, and we easily make our multiplication happen only on one axe, where other axe will shift to cancel out any operation on other axe.

O and A are addictive:
* We do them more and more in cycles of time, not one time in advance, so they are R space - component is used with component on the same position and downwards, it happens in value space, upwards in positional space of a number (T and R).
* For example, 56 + 56 is equal to multiplication with 2, so we subsequently multiply the R with 2 and thus, the other-axe-corrector (remember not going back in time, by _dividing_ something with 2, where we lose heads and lines, creating funny distortions by _R!≃T binary oppositions_)

U and V operate on addition and multiplication, doing something like normal and geometric averaging.

Truth Value Tables allow the unification of axes or separation of them.

Operations ideally happen:
* On I and E axe
* On OA number

For example:
OA * AI
EE * EE = EEEE
II * II = IIII

The resulting number, thus, adds the numbers of digits in R - coordinate system follows the multiplication factor and dimensionality won't distort; we can for example by result.R /= 2 make the result two times shorter, keeping it around our precision factors.

When we do it with adding, for example 2+2=4, resulting one bit added to the dimension. This must happen in complex part, where the change is rather equal - consider, the smallest value is the lower limit; indeed, be aware of your units here, either signed or unsigned.