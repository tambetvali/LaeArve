# Digit Spaces

## First Order Digit Space

Consider we have Classes as Templates, Instances as Instances.

In common base systems, base is part of Template: it's shared for every digit.

We say the ranges are:
- __base_10__: 0:10
- __base_2__: 0:2
- __base_8__: 0:8

Base 8: it's if one byte was a component of your number: it's equivalent to many binary transcriptions, especially if you first take the number into parts in binary: you need e and a part in number a*(10**e).

10, 2, 8: not 9, 1, 7, because we need five-number components later.

We do one digit operation:
- For each digit, we can separate the _range_ into separate component, and have powers for exponent.

Now: for each digit, do this separately.

Then, you have the digit space of dynamically sized digits.

We also have frequencies:
- Written like {I:A:E I:A:E I:A:E} etc., we would have 3-frequential number, and we could define the actual window is the middle, while the first number deccelerates by it's minus value, while the last number accelerates by it's plus value. With five or six digits, we involve I and E, and consequently V.
- If we have R and t parts: {I:A:E I:A:E I:A:E}{I:A:E I:A:E I:A:E}; we got two digits for space and time, and thus we can also affect the coordinate system: number in R means how much to change the coordinate system, so that it would fit the number.
- For AI fine-tuning: now we need coordinate system, because we want to use old training data, such as model weights and correction, and now train it to new correction; or if we re-train and use it in first place: we need the same way projection from imaginary future, where we assign positive number, while it might have negative if it's not reached, and negotive if it should have been targeted (not having alternatives, or being in suggested list of open targets).

Normally we write: AOOAIIEE; it's a 4-digit number with R and T digit, each entangled.